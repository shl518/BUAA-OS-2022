---
title: 2022操作系统Lab2实验报告
date: 2022-05-09 15:57:38
tags: 操作系统
---

### Lab2实验报告

### 思考题

#### Thinking 2.1

- **在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？**

**答**：指针变量中存储的地址是虚拟地址

- **MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？**

**答**：使用的是物理地址。

#### Thinking 2.2

- **请从可重用性的角度，阐述用宏来实现链表的好处。**

**答**：宏来实现链表，代码少，同时可以实现对链表的各种操作，使用时可以直接使用宏来操作链表，效率更高。

- **请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。**

**答**：插入操作上，如果插入到某一链表项之后，三者的性能差异不大。但是如果插入到某一链表项之前，三者存在差异，**对于单向链表和循环链表，因为当前链表项没有指向前一链表项的指针，无法得知前一个链表项的地址信息**，因此需要**循环**去寻找，单向链表**从链表头开始**逐一寻找，循环链表由于具有循环结构，可以**从当前链表项处往后**逐一寻找，但是**双向链表由于有指向前一链表项的指针**，可以直接得知前一链表项的地址，对前一链表项进行操作，不需要循环，**插入操作双向链表更加优越**。

对于删除操作，也涉及到对于前一链表项的操作，对于单向链表和循环链表同样需要循环寻找前一链表项，**双向链表也更加优越** 。

#### Thinking 2.3

答：C是正确的

#### Thinking 2.4

**请你寻找上述两个 boot_\* 函数在何处被调用。**

**答**：在`mips_vm_init`中被调用，该函数用于初始化二级页表。

#### Thinking 2.5

- 请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性

**答**：`ASID`是用于区分不同进程的一个标识符，操作系统可以运行多个进程，如果不使用`ASID`，那么进程切换后TLB内所有的内容都失效了，因为不同的进程虚拟地址和物理地址的映射关系不同，然而每次切换进程都要清空TLB显然不合理，因此引入`ASID`以区分不同进程，很好的解决了这一问题，TLB不需要每次切换都清空。

- 请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量

**答**：查询后得知，`ASID`占据了`EntryHi`寄存器的6~11位共6位，因此 R3000 中可容纳不同的地址空间的最大数量为64.

#### Thinking 2.6

- **tlb_invalidate 和 tlb_out 的调用关系是怎样的？**

**答**：tlb_invalidate 调用tlb_out。 

- **请用一句话概括 tlb_invalidate 的作用**

**答**：tlb_invalidate()作用是调用tlb_out()把va对应的TLB项清空。

- **逐行解释 tlb_out 中的汇编代码**

```c#
#include <asm/regdef.h>
#include <asm/cp0regdef.h>
#include <asm/asm.h>

LEAF(tlb_out)
//1: j 1b
nop
	mfc0	k1,CP0_ENTRYHI
	mtc0	a0,CP0_ENTRYHI  
	//1.这两条设置协处理器，读取并写入cp0的$10
	nop
	tlbp
	//2.tlbp指令，该指令检查TLB
	//如果TLB中有项和EntryHi寄存器匹配，就把Index寄存器设置为对应的项，
	//如果没有匹配的项，就把Index最高位设置为1
	nop
	nop
	nop
	nop
	mfc0	k0,CP0_INDEX
	bltz	k0,NOFOUND
	//3.读取Index的值，如果小于零，显然没找到，那就跳转到NOFOUND，
	
	nop
	mtc0	zero,CP0_ENTRYHI
	mtc0	zero,CP0_ENTRYLO0
	nop
	tlbwi
	//4.找到了，那就写入TLB
	//5.并且tlbwi把ENTRYHI和ENTRYLO0写入Index所指的项
NOFOUND:

	mtc0	k1,CP0_ENTRYHI
	
	j	ra
	//没有找到，恢复遍历之前的状况，跳转回之前函数
	nop
END(tlb_out)
```



#### Thinking 2.7

**在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位****系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase ，请你计算：

- **三级页表页目录的基地址**

**答**：`PTbase+(PTbase/1GB)*4KB`

- **映射到页目录自身的页目录项(自映射)**

**答**：`PTbase+(PTbase/1GB)*4KB+(PTbase/1GB)*4B`

#### Thinking 2.8

- **简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。**

**答**：x86架构的内存管理机制分为两部分：分段机制和分页机制。**分段机制**为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。**分页机制**实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。X86CPU发出逻辑地址，根据其中的段选择器和偏移查询全局描述符表和线性地址表得到线性地址，再通过分页，得到物理地址.

不过和MIPS不同的是，X86的分段是必须的，分页是不必须的，而且在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。 转换失败的地址则由CR3存放。



### 实验难点：

#### 难点一：

le_next是指针，le_prev是指向le_next的指针，是一个指针的指针，在理解LIST_INSERT_BEFORE 等函数的时候很容易绕晕，~~本人就被绕晕了~~，因为本身指针就比较绕，涉及到指针的指针就更绕了。以LIST_INSERT_BEFORE 为例，这里记录一下我对这一部分的理解，以防之后又被绕进去。

```cmake
#define LIST_INSERT_BEFORE(listelm, elm, field) do {                        \
                (elm)->field.le_prev = (listelm)->field.le_prev;                \
                //把elm的prev 直接换成 listlm的prev
                
                LIST_NEXT((elm), field) = (listelm);                            \
                //把elm的next 指向 listlm
                
                *(listelm)->field.le_prev = (elm);                              \
                //*(listelm)->field.le_prev 相当于取到原来listlm的前一个元素的next，将其指向elm
                //这里很巧妙，双重指针的用处就在这里，用来修改前一个元素的next指针
                
                (listelm)->field.le_prev = &LIST_NEXT((elm), field);            \
                //最后修改listlm的prev。让其指向elm的next，这里因为是双重指针，所以要用到&取址
        } while (0)
```

梳理好之后，终于才算是不绕了！

#### 难点二

关于二级页表的结构这一知识点，同样具有难度。其大致结构为我们首先需要将虚拟地址按照规定的结构拆分，得到页目录项，页表项以及偏移，并随着二级页表结构逐层向下查找，最终在根据页表查询的基地址加上偏移得到相应的物理地址。如下图:

![a](https://note.youdao.com/yws/api/personal/file/957CECEBA37D4283828C862617E53B9A?method=download&shareKey=074ceb5ddfb351b56b2b8e96c105764c)

#### 难点三

在本次实验中涉及到很多页面地址转换，虚拟地址与物理地址的转换，需要深刻理解和掌握才能熟练应用，在本次实验中我进行了整理记录

-  **page2pa：得到某个page结构体的物理地址**
-  **pa2page：得到某个物理地址所对应的Page结构体，是page2pa的逆操作**
-  **page2kva：得到某个Page结构体的内核虚拟地址**
-  **page2ppn：由页面得到对应的物理页号，因为Page对象在内存中是连续分布的所以可以直接减去首地址得到。**
-  **PADDR：将某个内核虚拟地址转化为物理地址**
-  **KADDR：将某个物理地址转化为内核虚拟地址**

### 体会与感想

这次的实验中，我感受到了很大的难度和极高的挑战度。首先是二级页表的知识，自映射相关的知识、虚拟，物理地址的知识我在理论课上没有掌握的很好。而做好课下课上实验必须要有理论知识的指导，理论知识的缺乏让我对这次`Lab2`实验感受到一定的难度。也算是在这次实验中得到了一个教训，实验做好的基础一定要把理论知识学好，在今后我将投入更多的时间和精力来扎实巩固我的理论知识。

 在lab2中，我更加体会到了熟练阅读代码，理解代码的重要性。lab2的大部分代码补全基本全部集中在pamp.c这一个函数中，在地址转化等操作中，所用到的函数和宏函数很多，他们之间的关系理解起来也有难度。如果想要让自己的实验进行更加顺利，需要对系统中的每一个代码都进行理解性阅读，搞清楚这个代码封装了哪些函数，主要用于实现哪些功能，只有这样，才能在使用函数时能够得心应手，节省时间。
